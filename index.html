<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ポモドーロタイマー</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Noto+Sans+JP:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <main class="page">
      <header class="hero">
        <div>
          <h1>ポモドーロタイマー</h1>
          <p class="lede">25分の集中と5分の休憩を自動で繰り返すシンプルなタイマーです。</p>
        </div>
      </header>
      <section class="card">
        <div id="root"></div>
      </section>
    </main>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel">
      const { useEffect, useMemo, useRef, useState } = React;

      const WORK_DURATION = 25 * 60; // seconds
      const BREAK_DURATION = 5 * 60; // seconds

      const STORAGE_KEY = "pomodoro_state_v2";

      const formatTime = (seconds) => {
        const safe = Math.max(0, Math.floor(seconds));
        const m = String(Math.floor(safe / 60)).padStart(2, "0");
        const s = String(safe % 60).padStart(2, "0");
        return `${m}:${s}`;
      };

      const IconWork = () => (
        <svg className="icon" viewBox="0 0 24 24" aria-hidden>
          <path
            fill="currentColor"
            d="M5 7h14a1 1 0 0 1 .99 1.14l-1 7A2 2 0 0 1 17 17H7a2 2 0 0 1-1.99-1.86l-1-7A1 1 0 0 1 5 7Zm5-3h4a1 1 0 0 1 1 1v2h-6V5a1 1 0 0 1 1-1Z"
          />
        </svg>
      );

      const IconBreak = () => (
        <svg className="icon" viewBox="0 0 24 24" aria-hidden>
          <path
            fill="currentColor"
            d="M7 6h10a1 1 0 0 1 .99 1.14L17 15a3 3 0 0 1-2.97 2.6H9.97A3 3 0 0 1 7 15L6.01 7.14A1 1 0 0 1 7 6Zm3 11h4a2 2 0 0 1 2 2v1H8v-1a2 2 0 0 1 2-2Z"
          />
        </svg>
      );

      const IconStatus = () => (
        <svg className="icon" viewBox="0 0 24 24" aria-hidden>
          <path
            fill="currentColor"
            d="M12 2a10 10 0 1 0 10 10A10.011 10.011 0 0 0 12 2Zm0 4a1.5 1.5 0 1 1-1.5 1.5A1.5 1.5 0 0 1 12 6Zm2 10h-4a1 1 0 0 1 0-2h1v-3h-1a1 1 0 0 1 0-2h2a1 1 0 0 1 1 1v4h1a1 1 0 0 1 0 2Z"
          />
        </svg>
      );

      const StatusIcon = ({ active }) => (
        <span className={`status-icon ${active ? "on" : "off"}`} aria-hidden>
          <IconStatus />
        </span>
      );

      const ModeBadge = ({ mode }) => (
        <span className={`badge ${mode === "work" ? "badge-work" : "badge-break"}`}>
          {mode === "work" ? <IconWork /> : <IconBreak />}
          <span>{mode === "work" ? "集中タイム" : "休憩タイム"}</span>
        </span>
      );

      const ProgressBar = ({ value }) => (
        <div
          className="progress"
          role="presentation"
          aria-hidden
          style={{ "--progress": value / 100, "--elapsed": 1 - value / 100 }}
        >
          <div className="progress-elapsed" />
          <div className="progress-value" />
        </div>
      );

      const durationSecondsForMode = (mode) => (mode === "work" ? WORK_DURATION : BREAK_DURATION);
      const durationMsForMode = (mode) => durationSecondsForMode(mode) * 1000;

      // 画面ロック / タブ移動で setInterval が止まっても復帰時に正しい残り時間へワープする設計。
      // 重要: 「残り秒」を真実にせず、「終了予定時刻 endAtMs」を真実にする。
      const PomodoroTimer = () => {
        const [mode, setMode] = useState("work");
        const [isRunning, setIsRunning] = useState(false);
        const [soundEnabled, setSoundEnabled] = useState(true);

        // endAtMs: 動作中のみ有効（現在モードが終了する予定の UNIX time ms）
        const [endAtMs, setEndAtMs] = useState(null);

        // pausedRemainingMs: 停止中のみ有効（再開時に使う残り ms）
        const [pausedRemainingMs, setPausedRemainingMs] = useState(null);

        // 画面表示を更新するための「ダミー」状態（これでレンダが走る）
        const [nowTick, setNowTick] = useState(() => Date.now());

        const firstRender = useRef(true);
        const prevModeRef = useRef(mode);

        const beep = () => {
          try {
            const Ctx = window.AudioContext || window.webkitAudioContext;
            if (!Ctx) return;
            const ctx = new Ctx();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = "sine";
            osc.frequency.value = 880;
            osc.connect(gain);
            gain.connect(ctx.destination);
            gain.gain.setValueAtTime(0.15, ctx.currentTime);
            osc.start();
            osc.stop(ctx.currentTime + 0.3);
            osc.onended = () => {
              try {
                ctx.close();
              } catch (e) {}
            };
          } catch (e) {
            // iOS等でユーザ操作なし再生が弾かれる場合があるため黙って無視
          }
        };

        const computeSecondsLeft = () => {
          if (isRunning && typeof endAtMs === "number") {
            return Math.ceil(Math.max(0, endAtMs - nowTick) / 1000);
          }
          if (!isRunning && typeof pausedRemainingMs === "number") {
            return Math.ceil(Math.max(0, pausedRemainingMs) / 1000);
          }
          return durationSecondsForMode(mode);
        };

        const secondsLeft = computeSecondsLeft();

        const progress = useMemo(() => {
          const base = durationSecondsForMode(mode);
          return (secondsLeft / base) * 100;
        }, [mode, secondsLeft]);

        // 進みすぎた時間を取り戻しつつ、モード遷移を処理する。
        const syncNow = () => {
          const now = Date.now();

          // running でなければ表示更新のみ
          if (!isRunning || typeof endAtMs !== "number") {
            setNowTick(now);
            return;
          }

          // endAtMs を越えていたら、経過分だけモード遷移する。
          // 例: ロック中に 30分経った場合、work→break→work と進める。
          let currentMode = mode;
          let currentEndAt = endAtMs;

          // 安全のため、無限ループ防止
          let guard = 0;
          while (now >= currentEndAt && guard < 20) {
            const nextMode = currentMode === "work" ? "break" : "work";
            currentMode = nextMode;
            currentEndAt = currentEndAt + durationMsForMode(nextMode);
            guard += 1;
          }

          // 大幅に時間が飛んだ場合のため、ガード上限に達したら数学的に前進させる
          if (now >= currentEndAt) {
            // 残りの遷移を概算で進める（work/breakの周期）
            const cycleMs = durationMsForMode("work") + durationMsForMode("break");
            const delta = now - currentEndAt;
            const jumpCycles = Math.floor(delta / cycleMs);
            currentEndAt += jumpCycles * cycleMs;

            // もう一度、最大2回だけ正確に合わせる
            for (let i = 0; i < 4 && now >= currentEndAt; i++) {
              const nextMode = currentMode === "work" ? "break" : "work";
              currentMode = nextMode;
              currentEndAt = currentEndAt + durationMsForMode(nextMode);
            }
          }

          // モードが変わっていたら反映
          if (currentMode !== mode) {
            setMode(currentMode);
          }
          if (currentEndAt !== endAtMs) {
            setEndAtMs(currentEndAt);
          }

          setNowTick(now);
        };

        // 画面更新用インターバル（バックグラウンドで止まっても問題ない）
        useEffect(() => {
          if (!isRunning) return;
          const id = setInterval(() => {
            syncNow();
          }, 500);
          return () => clearInterval(id);
          // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [isRunning, endAtMs, mode]);

        // hidden→visible 等で必ず追いつく
        useEffect(() => {
          const onVisibility = () => {
            if (document.visibilityState === "visible") {
              syncNow();
            }
          };
          const onFocus = () => syncNow();
          const onPageshow = () => syncNow();

          document.addEventListener("visibilitychange", onVisibility);
          window.addEventListener("focus", onFocus);
          window.addEventListener("pageshow", onPageshow);

          return () => {
            document.removeEventListener("visibilitychange", onVisibility);
            window.removeEventListener("focus", onFocus);
            window.removeEventListener("pageshow", onPageshow);
          };
          // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [isRunning, endAtMs, mode]);

        // モード切替音（モードが実際に変わった時だけ）
        useEffect(() => {
          if (firstRender.current) {
            firstRender.current = false;
            prevModeRef.current = mode;
            return;
          }

          const prevMode = prevModeRef.current;
          prevModeRef.current = mode;

          if (prevMode === mode) return;
          if (!isRunning || !soundEnabled) return;
          beep();
        }, [mode, isRunning, soundEnabled]);

        // 永続化: 状態を localStorage に保存
        useEffect(() => {
          const payload = {
            v: 2,
            mode,
            isRunning,
            soundEnabled,
            endAtMs,
            pausedRemainingMs,
          };
          try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
          } catch (e) {}
        }, [mode, isRunning, soundEnabled, endAtMs, pausedRemainingMs]);

        // 起動時に復元
        useEffect(() => {
          try {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (!raw) return;
            const parsed = JSON.parse(raw);
            if (!parsed || parsed.v !== 2) return;

            if (parsed.mode === "work" || parsed.mode === "break") setMode(parsed.mode);
            if (typeof parsed.soundEnabled === "boolean") setSoundEnabled(parsed.soundEnabled);
            if (typeof parsed.isRunning === "boolean") setIsRunning(parsed.isRunning);
            if (typeof parsed.endAtMs === "number") setEndAtMs(parsed.endAtMs);
            if (typeof parsed.pausedRemainingMs === "number") setPausedRemainingMs(parsed.pausedRemainingMs);

            // 復元直後に追いつく
            setTimeout(() => {
              // ここではまだ state が反映されていない可能性があるので nowTick だけ更新
              setNowTick(Date.now());
            }, 0);
          } catch (e) {}
          // eslint-disable-next-line react-hooks/exhaustive-deps
        }, []);

        // isRunning=true で endAtMs が無い場合（初回startや状態破損）に補正
        useEffect(() => {
          if (!isRunning) return;
          if (typeof endAtMs === "number") {
            syncNow();
            return;
          }

          const now = Date.now();
          const baseMs = typeof pausedRemainingMs === "number" ? pausedRemainingMs : durationMsForMode(mode);
          setPausedRemainingMs(null);
          setEndAtMs(now + baseMs);
          setNowTick(now);
          // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [isRunning]);

        const handleStart = () => {
          const now = Date.now();

          // 既に動作中なら何もしない
          if (isRunning) return;

          const remainMs = typeof pausedRemainingMs === "number" ? pausedRemainingMs : durationMsForMode(mode);
          setPausedRemainingMs(null);
          setEndAtMs(now + remainMs);
          setIsRunning(true);
          setNowTick(now);
        };

        const handleStop = () => {
          const now = Date.now();
          if (!isRunning) return;

          // 直前に追いついてから停止
          const remainMs = typeof endAtMs === "number" ? Math.max(0, endAtMs - now) : durationMsForMode(mode);
          setPausedRemainingMs(remainMs);
          setIsRunning(false);
          setEndAtMs(null);
          setNowTick(now);
        };

        const handleReset = () => {
          const now = Date.now();
          setIsRunning(false);
          setMode("work");
          setEndAtMs(null);
          setPausedRemainingMs(null);
          setNowTick(now);
        };

        return (
          <div className="timer">
            <div className="timer-header">
              <div className="title-group">
                <ModeBadge mode={mode} />
              </div>
              <div className="status">
                <StatusIcon active={isRunning} />
                <span className="status-label">{isRunning ? "動作中" : "一時停止"}</span>
              </div>
            </div>

            <div className="display">
              <p className="mode-label">{mode === "work" ? "集中タイム" : "休憩タイム"}</p>
              <p className="time" role="timer" aria-live="polite">
                {formatTime(secondsLeft)}
              </p>
              <p className="progress-info">残り {Math.round(progress)}%</p>
              <ProgressBar value={progress} />
            </div>

            <div className="controls" aria-label="タイマー操作">
              <button className="btn btn-primary" onClick={handleStart} disabled={isRunning}>
                スタート
              </button>
              <button className="btn btn-stop" onClick={handleStop} disabled={!isRunning}>
                ストップ
              </button>
              <button className="btn btn-outline" onClick={handleReset}>
                リセット
              </button>
            </div>

            <div className="toggle-row">
              <label className="switch">
                <input
                  type="checkbox"
                  checked={soundEnabled}
                  onChange={(e) => setSoundEnabled(e.target.checked)}
                />
                <span className="slider" aria-hidden></span>
                <span className="switch-label">切り替わり時のサウンドを鳴らす</span>
              </label>
            </div>

            <ul className="notes">
              <li>スタートを押すと25分の作業と5分の休憩を無限に繰り返します。</li>
              <li>ストップで現在のカウントを一時停止します。再度スタートで再開します。</li>
              <li>リセットすると25:00の作業タイマーから再スタートできます。</li>
              <li>スマホがロックされたり別タブへ移動しても、復帰時に正しい残り時間へ追いつきます。</li>
            </ul>
          </div>
        );
      };

      ReactDOM.createRoot(document.getElementById("root")).render(<PomodoroTimer />);
    </script>
  </body>
</html>
